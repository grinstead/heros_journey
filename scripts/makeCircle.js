import { readFileSync, writeFileSync } from "fs";
import { bufferToHex, hexToBuffer } from "../src/hex.js";
import parseSvgPath from "parse-svg-path";
import svgPathContours from "svg-path-contours";
import simplifyPath from "simplify-path";
import { default as Tess2 } from "tess2";

function main() {
  const data = readFileSync("assets/Heros Journey Test 2.svg", "utf8");

  const objects = [];
  let numTriangles = 0;
  const regex = /<path d="([^"]+)"/g;
  let match;
  while ((match = regex.exec(data))) {
    const path = match[1];

    const { positions, cells } = processPath(path);
    // svgMesh3d(path, {
    //   normalize: false,
    //   scale: 100,
    // });

    const posData = new Float32Array(3 * positions.length);
    positions.forEach(([x, y], i) => {
      posData[3 * i] = x;
      posData[3 * i + 1] = y;
      posData[3 * i + 2] = 0;
    });

    const ensureUint16 = (value) => {
      if (value < 0 || value >= 1 << 16) {
        throw new Error(`out-of-bounds cell: ${value}`);
      }
      return value;
    };

    const indexData = new Uint16Array(3 * cells.length);
    cells.forEach(([p1, p2, p3], i) => {
      indexData[3 * i] = ensureUint16(p1);
      indexData[3 * i + 1] = ensureUint16(p2);
      indexData[3 * i + 2] = ensureUint16(p3);
    });

    numTriangles += cells.length;

    // console.log(posData);

    objects.push(`{
      positions: "${bufferToHex(posData.buffer)}",
      cells: "${bufferToHex(indexData.buffer)}",
    }`);
  }

  console.log(`// @generated by 'node makeCircle.js'
// Total of ${numTriangles} triangles
export const TEST_DATA = [\n${objects.join(",\n")}];`);
}

function processPath(pathSpec) {
  const simplify = 0.05;
  const path = parseSvgPath(pathSpec);

  const contours = svgPathContours(path, 1000).map((c) => {
    let contour = c;

    if (simplify > 0) {
      contour = simplifyPath(contour, simplify);
    }

    return contour.flat();
  });

  const res = Tess2.tesselate({
    contours,
    windingRule: Tess2.WINDING_NONZERO,
    elementType: Tess2.POLYGONS,
    polySize: 3,
    vertexSize: 2,
  });

  const positions = [];
  const vertices = res.vertices;
  for (let i = 0; i < vertices.length; i += 2) {
    positions.push([vertices[i], vertices[i + 1], 0]);
  }

  const cells = [];
  const elements = res.elements;
  for (let i = 0; i < elements.length; i += 3) {
    cells.push([elements[i], elements[i + 1], elements[i + 2]]);
  }

  return { positions, cells };
}

main();
// build();
